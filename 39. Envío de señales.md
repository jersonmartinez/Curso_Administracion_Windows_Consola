# 39. Env√≠o de se√±ales üì°

> *"¬øAlguna vez te has preguntado c√≥mo controlar el comportamiento de programas en ejecuci√≥n? ¬øO c√≥mo enviar instrucciones espec√≠ficas a procesos sin terminarlos? El env√≠o de se√±ales es una t√©cnica avanzada que te permite comunicarte directamente con los procesos del sistema."*

## üìö Conceptos Clave

### **Se√±al (Signal)**
Mensaje enviado a un proceso para indicarle que debe realizar una acci√≥n espec√≠fica, como pausar, reanudar, o terminar su ejecuci√≥n de forma controlada.

### **PID (Process ID)**
Identificador √∫nico asignado a cada proceso en ejecuci√≥n, necesario para enviar se√±ales espec√≠ficas a procesos particulares.

### **Interrupci√≥n (Interrupt)**
Mecanismo por el cual un proceso puede ser interrumpido temporalmente para recibir una se√±al y responder apropiadamente.

### **Manejo de Se√±ales (Signal Handling)**
Proceso mediante el cual un programa recibe, interpreta y responde a las se√±ales enviadas por el sistema o por otros procesos.

## üõ†Ô∏è Comandos Principales

### **TASKKILL**
Comando nativo de Windows para terminar procesos enviando se√±ales de terminaci√≥n.

```batch
taskkill /PID 1234 /F
```

### **WMIC PROCESS**
Herramienta de l√≠nea de comandos para gestionar procesos y enviar se√±ales espec√≠ficas.

```batch
wmic process where "ProcessId=1234" call terminate
```

### **POWERSHELL Stop-Process**
Cmdlet de PowerShell para enviar se√±ales de terminaci√≥n a procesos con opciones avanzadas.

```powershell
Stop-Process -Id 1234 -Force
```

### **SIGNAL.EXE**
Herramienta avanzada para enviar se√±ales espec√≠ficas a procesos (requiere instalaci√≥n).

```batch
signal.exe -p 1234 -s SIGTERM
```

## üí° Ejemplos Pr√°cticos

### **Ejemplo 1: Terminar proceso por PID**
**Prop√≥sito**: Terminar un proceso espec√≠fico usando su identificador √∫nico, √∫til cuando un programa no responde o consume demasiados recursos.

```batch
@echo off
echo Terminando proceso por PID...
set /p pid="Ingresa el PID del proceso: "
taskkill /PID %pid% /F
if %errorlevel%==0 (
    echo Proceso %pid% terminado exitosamente
) else (
    echo Error al terminar el proceso
)
pause
```

### **Ejemplo 2: Terminar proceso por nombre**
**Prop√≥sito**: Terminar todos los procesos con un nombre espec√≠fico, √∫til para cerrar m√∫ltiples instancias de una aplicaci√≥n.

```batch
@echo off
echo Terminando proceso por nombre...
set /p nombre="Ingresa el nombre del proceso: "
taskkill /IM "%nombre%" /F
if %errorlevel%==0 (
    echo Todos los procesos "%nombre%" terminados
) else (
    echo Error al terminar los procesos
)
pause
```

### **Ejemplo 3: Enviar se√±al de terminaci√≥n suave**
**Prop√≥sito**: Enviar una se√±al de terminaci√≥n que permite al proceso cerrarse de forma ordenada, guardando datos si es necesario.

```batch
@echo off
echo Enviando se√±al de terminaci√≥n suave...
set /p pid="Ingresa el PID del proceso: "
taskkill /PID %pid%
if %errorlevel%==0 (
    echo Se√±al de terminaci√≥n enviada al proceso %pid%
) else (
    echo Error al enviar se√±al
)
pause
```

### **Ejemplo 4: Terminar procesos de un usuario espec√≠fico**
**Prop√≥sito**: Terminar todos los procesos pertenecientes a un usuario en particular, √∫til en entornos multiusuario.

```batch
@echo off
echo Terminando procesos de usuario espec√≠fico...
set /p usuario="Ingresa el nombre del usuario: "
taskkill /FI "USERNAME eq %usuario%" /F
if %errorlevel%==0 (
    echo Procesos del usuario %usuario% terminados
) else (
    echo Error al terminar procesos
)
pause
```

### **Ejemplo 5: Verificar proceso antes de terminar**
**Prop√≥sito**: Verificar que el proceso existe y obtener informaci√≥n antes de enviar la se√±al de terminaci√≥n.

```batch
@echo off
echo Verificando proceso antes de terminar...
set /p pid="Ingresa el PID del proceso: "
tasklist /FI "PID eq %pid%"
if %errorlevel%==0 (
    echo.
    set /p confirm="¬øDeseas terminar este proceso? (s/n): "
    if /i "%confirm%"=="s" (
        taskkill /PID %pid% /F
        echo Proceso terminado
    )
) else (
    echo Proceso no encontrado
)
pause
```

### **Ejemplo 6: Terminar procesos por uso de memoria**
**Prop√≥sito**: Identificar y terminar procesos que consumen m√°s memoria de la permitida, √∫til para gesti√≥n de recursos.

```batch
@echo off
echo Buscando procesos con alto uso de memoria...
set /p limite="L√≠mite de memoria en MB: "
for /f "tokens=2,5" %%a in ('tasklist /FI "MEMUSAGE gt %limite%000" /FO CSV') do (
    echo Terminando proceso %%a (%%b KB)
    taskkill /PID %%a /F
)
echo Procesos con alto uso de memoria terminados
pause
```

### **Ejemplo 7: Enviar se√±al a proceso remoto**
**Prop√≥sito**: Enviar se√±ales a procesos en equipos remotos, √∫til para administraci√≥n de sistemas distribuidos.

```batch
@echo off
echo Enviando se√±al a proceso remoto...
set /p equipo="Nombre/IP del equipo: "
set /p pid="PID del proceso: "
taskkill /S %equipo% /PID %pid% /F
if %errorlevel%==0 (
    echo Se√±al enviada al proceso %pid% en %equipo%
) else (
    echo Error al enviar se√±al remota
)
pause
```

### **Ejemplo 8: Terminar procesos por tiempo de ejecuci√≥n**
**Prop√≥sito**: Terminar procesos que han estado ejecut√°ndose por m√°s tiempo del permitido, √∫til para evitar procesos zombi.

```batch
@echo off
echo Terminando procesos por tiempo de ejecuci√≥n...
set /p tiempo="Tiempo m√°ximo en minutos: "
for /f "tokens=2" %%a in ('tasklist /FI "CPUTIME gt %tiempo%:00" /FO CSV') do (
    echo Terminando proceso %%a (tiempo excedido)
    taskkill /PID %%a /F
)
echo Procesos con tiempo excedido terminados
pause
```

### **Ejemplo 9: Enviar se√±al de pausa**
**Prop√≥sito**: Pausar temporalmente un proceso sin terminarlo, √∫til para liberar recursos temporalmente.

```batch
@echo off
echo Pausando proceso...
set /p pid="Ingresa el PID del proceso: "
wmic process where "ProcessId=%pid%" call suspend
if %errorlevel%==0 (
    echo Proceso %pid% pausado
    set /p reanudar="¬øDeseas reanudar el proceso? (s/n): "
    if /i "%reanudar%"=="s" (
        wmic process where "ProcessId=%pid%" call resume
        echo Proceso reanudado
    )
) else (
    echo Error al pausar el proceso
)
pause
```

### **Ejemplo 10: Script de gesti√≥n de se√±ales**
**Prop√≥sito**: Script interactivo para gestionar diferentes tipos de se√±ales y procesos con m√∫ltiples opciones.

```batch
@echo off
title Gesti√≥n de Se√±ales de Procesos
color 0F

:menu
cls
echo ========================================
echo    GESTION DE SE√ëALES DE PROCESOS
echo ========================================
echo.
echo 1. Ver procesos activos
echo 2. Terminar proceso por PID
echo 3. Terminar proceso por nombre
echo 4. Terminar procesos de usuario
echo 5. Pausar/Reanudar proceso
echo 6. Terminar procesos por memoria
echo 7. Terminar procesos por tiempo
echo 8. Enviar se√±al remota
echo 9. Salir
echo.
set /p opcion="Selecciona una opci√≥n (1-9): "

if "%opcion%"=="1" goto procesos
if "%opcion%"=="2" goto pid
if "%opcion%"=="3" goto nombre
if "%opcion%"=="4" goto usuario
if "%opcion%"=="5" goto pausar
if "%opcion%"=="6" goto memoria
if "%opcion%"=="7" goto tiempo
if "%opcion%"=="8" goto remoto
if "%opcion%"=="9" goto salir
goto menu

:procesos
cls
echo === PROCESOS ACTIVOS ===
tasklist /FO TABLE
pause
goto menu

:pid
cls
echo === TERMINAR POR PID ===
set /p pid="PID del proceso: "
taskkill /PID %pid% /F
if %errorlevel%==0 (
    echo ‚úì Proceso %pid% terminado
) else (
    echo ‚úó Error al terminar proceso
)
pause
goto menu

:nombre
cls
echo === TERMINAR POR NOMBRE ===
set /p nombre="Nombre del proceso: "
taskkill /IM "%nombre%" /F
if %errorlevel%==0 (
    echo ‚úì Procesos "%nombre%" terminados
) else (
    echo ‚úó Error al terminar procesos
)
pause
goto menu

:usuario
cls
echo === TERMINAR POR USUARIO ===
set /p usuario="Nombre del usuario: "
taskkill /FI "USERNAME eq %usuario%" /F
if %errorlevel%==0 (
    echo ‚úì Procesos del usuario %usuario% terminados
) else (
    echo ‚úó Error al terminar procesos
)
pause
goto menu

:pausar
cls
echo === PAUSAR/REANUDAR PROCESO ===
set /p pid="PID del proceso: "
set /p accion="Acci√≥n (p=pausar, r=reanudar): "
if /i "%accion%"=="p" (
    wmic process where "ProcessId=%pid%" call suspend
    echo ‚úì Proceso pausado
) else if /i "%accion%"=="r" (
    wmic process where "ProcessId=%pid%" call resume
    echo ‚úì Proceso reanudado
)
pause
goto menu

:memoria
cls
echo === TERMINAR POR MEMORIA ===
set /p limite="L√≠mite de memoria (MB): "
for /f "tokens=2" %%a in ('tasklist /FI "MEMUSAGE gt %limite%000" /FO CSV') do (
    taskkill /PID %%a /F
    echo ‚úì Proceso %%a terminado
)
pause
goto menu

:tiempo
cls
echo === TERMINAR POR TIEMPO ===
set /p tiempo="Tiempo m√°ximo (minutos): "
for /f "tokens=2" %%a in ('tasklist /FI "CPUTIME gt %tiempo%:00" /FO CSV') do (
    taskkill /PID %%a /F
    echo ‚úì Proceso %%a terminado
)
pause
goto menu

:remoto
cls
echo === SE√ëAL REMOTA ===
set /p equipo="Equipo remoto: "
set /p pid="PID del proceso: "
taskkill /S %equipo% /PID %pid% /F
if %errorlevel%==0 (
    echo ‚úì Se√±al enviada a %equipo%
) else (
    echo ‚úó Error al enviar se√±al
)
pause
goto menu

:salir
echo Gracias por usar el gestor de se√±ales
exit
```

## üîß Script para Gesti√≥n Avanzada de Se√±ales

```batch
@echo off
title Gesti√≥n Avanzada de Se√±ales de Procesos
color 0A

:: Verificar permisos de administrador
net session >nul 2>&1
if %errorlevel% neq 0 (
    echo ERROR: Este script requiere permisos de administrador
    echo Ejecuta como administrador y vuelve a intentar
    pause
    exit /b 1
)

:: Variables globales
set "LOG_FILE=se√±ales.log"
set "CONFIG_FILE=se√±ales.conf"

:: Funci√≥n para logging
:log
echo [%date% %time%] %~1 >> "%LOG_FILE%"
goto :eof

:: Funci√≥n para verificar proceso
:check_process
set "pid=%~1"
tasklist /FI "PID eq %pid%" >nul 2>&1
if %errorlevel%==0 (
    echo ‚úì Proceso %pid% encontrado
    call :log "Proceso %pid% verificado como existente"
) else (
    echo ‚úó Proceso %pid% no encontrado
    call :log "Error: Proceso %pid% no encontrado"
)
goto :eof

:: Funci√≥n para obtener informaci√≥n del proceso
:get_process_info
set "pid=%~1"
echo Obteniendo informaci√≥n del proceso %pid%...
for /f "tokens=1-5" %%a in ('tasklist /FI "PID eq %pid%" /FO CSV') do (
    echo Nombre: %%a
    echo PID: %%b
    echo Sesi√≥n: %%c
    echo Memoria: %%d
    echo Estado: %%e
)
call :log "Informaci√≥n del proceso %pid% obtenida"
goto :eof

:: Funci√≥n para enviar se√±al de terminaci√≥n suave
:send_soft_signal
set "pid=%~1"
echo Enviando se√±al de terminaci√≥n suave al proceso %pid%...
taskkill /PID %pid%
if %errorlevel%==0 (
    echo ‚úì Se√±al suave enviada al proceso %pid%
    call :log "Se√±al suave enviada exitosamente al proceso %pid%"
) else (
    echo ‚úó Error al enviar se√±al suave
    call :log "Error al enviar se√±al suave al proceso %pid%"
)
goto :eof

:: Funci√≥n para enviar se√±al de terminaci√≥n forzada
:send_force_signal
set "pid=%~1"
echo Enviando se√±al de terminaci√≥n forzada al proceso %pid%...
taskkill /PID %pid% /F
if %errorlevel%==0 (
    echo ‚úì Se√±al forzada enviada al proceso %pid%
    call :log "Se√±al forzada enviada exitosamente al proceso %pid%"
) else (
    echo ‚úó Error al enviar se√±al forzada
    call :log "Error al enviar se√±al forzada al proceso %pid%"
)
goto :eof

:: Funci√≥n para pausar proceso
:suspend_process
set "pid=%~1"
echo Pausando proceso %pid%...
wmic process where "ProcessId=%pid%" call suspend
if %errorlevel%==0 (
    echo ‚úì Proceso %pid% pausado
    call :log "Proceso %pid% pausado exitosamente"
) else (
    echo ‚úó Error al pausar proceso
    call :log "Error al pausar proceso %pid%"
)
goto :eof

:: Funci√≥n para reanudar proceso
:resume_process
set "pid=%~1"
echo Reanudando proceso %pid%...
wmic process where "ProcessId=%pid%" call resume
if %errorlevel%==0 (
    echo ‚úì Proceso %pid% reanudado
    call :log "Proceso %pid% reanudado exitosamente"
) else (
    echo ‚úó Error al reanudar proceso
    call :log "Error al reanudar proceso %pid%"
)
goto :eof

:: Funci√≥n para monitoreo de procesos
:process_monitor
echo === MONITOREO DE PROCESOS ===
echo Presiona 'q' para salir, 'r' para refrescar
:monitor_loop
cls
echo [%date% %time%] - Monitoreo de Procesos
echo ======================================
echo.
echo Procesos con mayor uso de CPU:
tasklist /FO TABLE /FI "CPUTIME gt 00:05:00"
echo.
echo Procesos con mayor uso de memoria:
tasklist /FO TABLE /FI "MEMUSAGE gt 100000"
echo.
echo Comandos: q=salir, r=refrescar
choice /c qr /n /t 10 /d r >nul
if errorlevel 2 goto monitor_loop
if errorlevel 1 goto :eof
goto monitor_loop

:: Funci√≥n para gesti√≥n masiva de procesos
:mass_process_management
echo === GESTI√ìN MASIVA DE PROCESOS ===
echo.
echo 1. Terminar procesos por patr√≥n de nombre
echo 2. Terminar procesos por uso de memoria
echo 3. Terminar procesos por tiempo de CPU
echo 4. Pausar todos los procesos de un usuario
echo.
set /p choice="Selecciona opci√≥n (1-4): "

if "%choice%"=="1" (
    set /p pattern="Patr√≥n de nombre: "
    for /f "tokens=2" %%a in ('tasklist /FI "IMAGENAME eq %pattern%*" /FO CSV') do (
        taskkill /PID %%a /F
        echo ‚úì Proceso %%a terminado
        call :log "Proceso %%a terminado por patr√≥n %pattern%"
    )
)
if "%choice%"=="2" (
    set /p limit="L√≠mite de memoria (MB): "
    for /f "tokens=2" %%a in ('tasklist /FI "MEMUSAGE gt %limit%000" /FO CSV') do (
        taskkill /PID %%a /F
        echo ‚úì Proceso %%a terminado
        call :log "Proceso %%a terminado por memoria %limit%MB"
    )
)
if "%choice%"=="3" (
    set /p time="Tiempo m√°ximo (HH:MM): "
    for /f "tokens=2" %%a in ('tasklist /FI "CPUTIME gt %time%" /FO CSV') do (
        taskkill /PID %%a /F
        echo ‚úì Proceso %%a terminado
        call :log "Proceso %%a terminado por tiempo %time%"
    )
)
if "%choice%"=="4" (
    set /p user="Usuario: "
    for /f "tokens=2" %%a in ('tasklist /FI "USERNAME eq %user%" /FO CSV') do (
        wmic process where "ProcessId=%%a" call suspend
        echo ‚úì Proceso %%a pausado
        call :log "Proceso %%a pausado para usuario %user%"
    )
)
pause
goto :eof

:: Funci√≥n para se√±ales remotas
:remote_signals
echo === SE√ëALES REMOTAS ===
echo.
set /p computer="Equipo remoto: "
set /p action="Acci√≥n (list/terminate/suspend/resume): "

if /i "%action%"=="list" (
    tasklist /S %computer% /FO TABLE
    call :log "Lista de procesos obtenida del equipo %computer%"
)
if /i "%action%"=="terminate" (
    set /p pid="PID del proceso: "
    taskkill /S %computer% /PID %pid% /F
    echo ‚úì Proceso %pid% terminado en %computer%
    call :log "Proceso %pid% terminado remotamente en %computer%"
)
if /i "%action%"=="suspend" (
    set /p pid="PID del proceso: "
    wmic /node:%computer% process where "ProcessId=%pid%" call suspend
    echo ‚úì Proceso %pid% pausado en %computer%
    call :log "Proceso %pid% pausado remotamente en %computer%"
)
if /i "%action%"=="resume" (
    set /p pid="PID del proceso: "
    wmic /node:%computer% process where "ProcessId=%pid%" call resume
    echo ‚úì Proceso %pid% reanudado en %computer%
    call :log "Proceso %pid% reanudado remotamente en %computer%"
)
pause
goto :eof

:: Men√∫ principal
:main_menu
cls
echo ========================================
echo    GESTION AVANZADA DE SE√ëALES
echo ========================================
echo.
echo 1. Verificar proceso por PID
echo 2. Obtener informaci√≥n de proceso
echo 3. Enviar se√±al de terminaci√≥n suave
echo 4. Enviar se√±al de terminaci√≥n forzada
echo 5. Pausar proceso
echo 6. Reanudar proceso
echo 7. Monitoreo de procesos
echo 8. Gesti√≥n masiva de procesos
echo 9. Se√±ales remotas
echo 10. Ver logs del sistema
echo 0. Salir
echo.
set /p choice="Selecciona una opci√≥n (0-10): "

if "%choice%"=="1" (
    set /p pid="PID del proceso: "
    call :check_process %pid%
    pause
    goto main_menu
)
if "%choice%"=="2" (
    set /p pid="PID del proceso: "
    call :get_process_info %pid%
    pause
    goto main_menu
)
if "%choice%"=="3" (
    set /p pid="PID del proceso: "
    call :send_soft_signal %pid%
    pause
    goto main_menu
)
if "%choice%"=="4" (
    set /p pid="PID del proceso: "
    call :send_force_signal %pid%
    pause
    goto main_menu
)
if "%choice%"=="5" (
    set /p pid="PID del proceso: "
    call :suspend_process %pid%
    pause
    goto main_menu
)
if "%choice%"=="6" (
    set /p pid="PID del proceso: "
    call :resume_process %pid%
    pause
    goto main_menu
)
if "%choice%"=="7" (
    call :process_monitor
    goto main_menu
)
if "%choice%"=="8" (
    call :mass_process_management
    goto main_menu
)
if "%choice%"=="9" (
    call :remote_signals
    goto main_menu
)
if "%choice%"=="10" (
    if exist "%LOG_FILE%" (
        type "%LOG_FILE%"
    ) else (
        echo No hay logs disponibles
    )
    pause
    goto main_menu
)
if "%choice%"=="0" (
    echo Gracias por usar el gestor avanzado de se√±ales
    exit /b 0
)
goto main_menu
```

## üîß Script para Sistema de Control de Procesos

```batch
@echo off
title Sistema de Control de Procesos
color 0B

:: Verificar permisos de administrador
net session >nul 2>&1
if %errorlevel% neq 0 (
    echo ERROR: Se requieren permisos de administrador
    pause
    exit /b 1
)

:: Variables del sistema
set "CONTROL_LOG=control_procesos.log"
set "RULES_FILE=reglas_procesos.conf"

:: Crear archivo de reglas si no existe
if not exist "%RULES_FILE%" (
    echo Creando archivo de reglas de control...
    (
        echo # Reglas de Control de Procesos
        echo MAX_MEMORY=500
        echo MAX_CPU_TIME=30
        echo AUTO_TERMINATE=true
        echo SUSPEND_THRESHOLD=80
        echo MONITOR_INTERVAL=60
    ) > "%RULES_FILE%"
    echo Archivo de reglas creado: %RULES_FILE%
    echo Edita el archivo y ejecuta nuevamente el script
    pause
    exit /b 0
)

:: Funci√≥n para logging de control
:log_control
echo [%date% %time%] CONTROL: %~1 >> "%CONTROL_LOG%"
goto :eof

:: Funci√≥n para cargar reglas
:load_rules
for /f "tokens=1,2 delims==" %%a in (%RULES_FILE%) do (
    if "%%a"=="MAX_MEMORY" set "max_memory=%%b"
    if "%%a"=="MAX_CPU_TIME" set "max_cpu_time=%%b"
    if "%%a"=="AUTO_TERMINATE" set "auto_terminate=%%b"
    if "%%a"=="SUSPEND_THRESHOLD" set "suspend_threshold=%%b"
    if "%%a"=="MONITOR_INTERVAL" set "monitor_interval=%%b"
)
goto :eof

:: Funci√≥n para verificar reglas
:check_rules
call :load_rules
call :log_control "Verificando reglas de control"

:: Verificar procesos por memoria
for /f "tokens=2,4" %%a in ('tasklist /FI "MEMUSAGE gt %max_memory%000" /FO CSV') do (
    echo Proceso %%a excede l√≠mite de memoria: %%b KB
    if /i "%auto_terminate%"=="true" (
        taskkill /PID %%a /F
        echo ‚úì Proceso %%a terminado por memoria
        call :log_control "Proceso %%a terminado por exceso de memoria"
    ) else (
        wmic process where "ProcessId=%%a" call suspend
        echo ‚úì Proceso %%a pausado por memoria
        call :log_control "Proceso %%a pausado por exceso de memoria"
    )
)

:: Verificar procesos por tiempo de CPU
for /f "tokens=2" %%a in ('tasklist /FI "CPUTIME gt 00:%max_cpu_time%:00" /FO CSV') do (
    echo Proceso %%a excede tiempo de CPU
    if /i "%auto_terminate%"=="true" (
        taskkill /PID %%a /F
        echo ‚úì Proceso %%a terminado por tiempo
        call :log_control "Proceso %%a terminado por exceso de tiempo"
    ) else (
        wmic process where "ProcessId=%%a" call suspend
        echo ‚úì Proceso %%a pausado por tiempo
        call :log_control "Proceso %%a pausado por exceso de tiempo"
    )
)
goto :eof

:: Funci√≥n para monitoreo autom√°tico
:auto_monitor
echo Sistema de Control de Procesos iniciado
echo Presiona Ctrl+C para detener
call :log_control "Sistema de control iniciado"

:monitor_loop
call :check_rules
timeout /t %monitor_interval% /nobreak >nul
goto monitor_loop

:: Funci√≥n para gesti√≥n de reglas
:manage_rules
echo === GESTI√ìN DE REGLAS ===
echo.
echo 1. Ver reglas actuales
echo 2. Editar reglas
echo 3. Restaurar reglas por defecto
echo 4. Probar reglas
echo.
set /p choice="Selecciona opci√≥n (1-4): "

if "%choice%"=="1" (
    echo Reglas actuales:
    type "%RULES_FILE%"
    call :log_control "Reglas mostradas"
)
if "%choice%"=="2" (
    notepad "%RULES_FILE%"
    call :log_control "Reglas editadas"
)
if "%choice%"=="3" (
    echo Restaurando reglas por defecto...
    (
        echo # Reglas de Control de Procesos
        echo MAX_MEMORY=500
        echo MAX_CPU_TIME=30
        echo AUTO_TERMINATE=true
        echo SUSPEND_THRESHOLD=80
        echo MONITOR_INTERVAL=60
    ) > "%RULES_FILE%"
    echo ‚úì Reglas restauradas
    call :log_control "Reglas restauradas por defecto"
)
if "%choice%"=="4" (
    echo Probando reglas de control...
    call :check_rules
    echo ‚úì Prueba completada
    call :log_control "Prueba de reglas ejecutada"
)
pause
goto :eof

:: Men√∫ principal
:main_menu
cls
echo ========================================
echo    SISTEMA DE CONTROL DE PROCESOS
echo ========================================
echo.
echo 1. Iniciar monitoreo autom√°tico
echo 2. Verificar reglas manualmente
echo 3. Gesti√≥n de reglas
echo 4. Ver historial de control
echo 5. Configurar alertas
echo 6. Probar sistema
echo 0. Salir
echo.
set /p choice="Selecciona una opci√≥n (0-6): "

if "%choice%"=="1" (
    call :auto_monitor
    goto main_menu
)
if "%choice%"=="2" (
    call :check_rules
    pause
    goto main_menu
)
if "%choice%"=="3" (
    call :manage_rules
    goto main_menu
)
if "%choice%"=="4" (
    if exist "%CONTROL_LOG%" (
        type "%CONTROL_LOG%"
    ) else (
        echo No hay historial de control
    )
    pause
    goto main_menu
)
if "%choice%"=="5" (
    echo Configurando alertas...
    set /p email="Email para alertas: "
    echo Alerta configurada para: %email%
    call :log_control "Alerta configurada para %email%"
    pause
    goto main_menu
)
if "%choice%"=="6" (
    echo Probando sistema de control...
    call :check_rules
    echo ‚úì Sistema probado correctamente
    call :log_control "Sistema probado manualmente"
    pause
    goto main_menu
)
if "%choice%"=="0" (
    echo Sistema de control cerrado
    exit /b 0
)
goto main_menu
```

## üí° Consejos Importantes

### **Optimizaci√≥n**
- **Verificar antes de enviar**: Siempre verifica que el proceso existe antes de enviar se√±ales
- **Usar se√±ales suaves primero**: Intenta con terminaci√≥n suave antes de usar fuerza
- **Monitorear recursos**: Mant√©n un ojo en el uso de CPU y memoria de los procesos

### **Seguridad**
- **Verificar permisos**: Aseg√∫rate de tener los permisos necesarios para enviar se√±ales
- **No terminar procesos cr√≠ticos**: Evita terminar procesos del sistema sin conocimiento
- **Registrar acciones**: Mant√©n logs de todas las se√±ales enviadas para auditor√≠a

### **Mejores Pr√°cticas**
- **Comunicar cambios**: Informa a los usuarios antes de terminar procesos importantes
- **Usar pausa en lugar de terminaci√≥n**: Cuando sea posible, pausa procesos en lugar de terminarlos
- **Monitorear efectos**: Verifica que las se√±ales no afecten otros procesos del sistema

## üåç Casos de Uso Reales

### **Administraci√≥n de Sistemas**
- **Gesti√≥n de recursos**: Controlar procesos que consumen demasiados recursos del sistema
- **Mantenimiento programado**: Pausar procesos antes de realizar mantenimiento
- **Recuperaci√≥n de emergencia**: Terminar procesos problem√°ticos en situaciones cr√≠ticas

### **Entornos de Desarrollo**
- **Control de aplicaciones**: Gestionar procesos de desarrollo y testing
- **Optimizaci√≥n de rendimiento**: Identificar y controlar procesos que afectan el rendimiento
- **Debugging**: Pausar procesos para an√°lisis y debugging

### **Empresas**
- **Gesti√≥n de estaciones de trabajo**: Controlar procesos en equipos de usuarios
- **Cumplimiento de pol√≠ticas**: Aplicar reglas de uso de recursos corporativas
- **Monitoreo de seguridad**: Detectar y controlar procesos sospechosos

## üéØ Conclusi√≥n y Siguiente Paso

¬°Excelente! Has dominado el env√≠o de se√±ales a procesos en Windows. Esta habilidad avanzada te permitir√° controlar el comportamiento de programas en ejecuci√≥n, una competencia esencial para administradores de sistemas y desarrolladores.

**¬øQu√© has aprendido?**
- Enviar diferentes tipos de se√±ales a procesos espec√≠ficos
- Controlar procesos por PID, nombre o usuario
- Pausar y reanudar procesos sin terminarlos
- Gestionar procesos remotos y en masa
- Crear sistemas de control autom√°tico de procesos

**Aplicaciones profesionales:**
- Administrador de sistemas avanzado
- Ingeniero de DevOps
- Desarrollador de aplicaciones de sistema
- Consultor de rendimiento y optimizaci√≥n

En el siguiente cap√≠tulo, aprender√°s sobre **ejecutar como administrador** usando el comando RUNAS, una habilidad fundamental para gestionar permisos y ejecutar aplicaciones con privilegios elevados. ¬°Prep√°rate para dominar la gesti√≥n de privilegios!

---

## üìö Enlaces Relacionados

- [Cap√≠tulo 34: Gesti√≥n de Procesos](34.%20Gesti√≥n%20de%20Procesos.md)
- [Cap√≠tulo 38: Enviar mensajes a usuarios](38.%20Enviar%20mensajes%20a%20usuarios.md)
- [Cap√≠tulo 40: Ejecutar como Administrador - RUNAS](40.%20Ejecutar%20como%20Administrador%20-%20RUNAS.md)

## üîó Fuentes y Referencias

- **Microsoft Docs**: [TASKKILL Command](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/taskkill)
- **Windows Process Management**: [WMIC Process](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmic)
- **PowerShell Documentation**: [Stop-Process Cmdlet](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/stop-process)
- **Autor**: [Jerson Mart√≠nez](https://jersonmartinez.com)
- **Blog DevOps**: [Crashell](https://crashell.com) 